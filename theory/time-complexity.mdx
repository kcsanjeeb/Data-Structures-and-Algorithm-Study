---
title: "Complexity Calculation (My Simple Way)"
description: "A simple and clear explanation of time and space complexity for coding interviews."
---

## **Complexity Calculation (My Simple Way)**

---

# **üïí Time Complexity**

### **1. Single Loop**
```go
for i := 0; i < n; i++ {    // runs n times
    x = y + z               // constant time (c)
}
```

- Total time = `c * n`  
- In Big-O, we ignore constants ‚áí **O(n)**

---

### **2. Nested Loop**
```go
for i := 0; i < n; i++ {        // n times
    for j := 1; j < n; j++ {    // n times
        x = y + z               // constant time (c)
    }
}
```

- Total time = `n * n * c = c * n¬≤`  
- Ignoring constant `c` ‚áí **O(n¬≤)**

---

### **3. Sequential Statements**
```go
a = a + b         // constant time c‚ÇÅ

for i := 0; i < n; i++ {    // n times
    x = y + z               // constant time c‚ÇÇ
}

for j := 0; j < n; j++ {    // n times
    j = k + l               // constant time c‚ÇÉ
}
```

- Total = `c‚ÇÅ + n*c‚ÇÇ + n*c‚ÇÉ`  
- Ignore constants ‚áí `n + n = 2n ‚âà O(n)`  
‚úÖ **Final complexity: O(n)**

---

### **4. If-Else Statements**
```go
if condition {
    // Suppose this block has O(n)
} else {
    // Suppose this block has O(n¬≤)
}
```

- The total complexity = **max(O(n), O(n¬≤)) = O(n¬≤)**  
- Always consider the **worst-case** branch.

---

### **Hierarchy of Common Complexities**

| Notation | Description | Example |
|-----------|--------------|----------|
| O(1) | Constant | Access by index |
| O(log n) | Logarithmic | Binary search |
| O(n) | Linear | Single loop |
| O(n log n) | Log-linear | Merge sort |
| O(n¬≤) | Quadratic | Nested loops |
| O(n¬≥) | Cubic | 3 nested loops |
| O(2‚Åø) | Exponential | Recursion with 2 branches |
| O(n!) | Factorial | Permutation generation |

üìà **Order of Growth (from best ‚Üí worst):**

> O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2‚Åø) < O(n!)

---

![Sorting And Searching Algorithms - Time Complexities Cheat Sheet | HackerEarth](https://he-s3.s3.amazonaws.com/media/uploads/c950295.png)

---

# **üíæ Space Complexity**

Let‚Äôs assume an `int` takes **4 bytes** of memory:

```go
var a int       // 4 bytes
var b int       // 4 bytes
var c int       // 4 bytes
var z int       
z = a + b + c   // 4 bytes
return z        // 4 bytes
```

- Total memory = `4 * 4 + 4(return)` = **20 bytes**

‚úÖ Hence, **Space Complexity = O(1)**  
(because it‚Äôs constant, independent of input size)

---

## **‚öñÔ∏è Space‚ÄìTime Trade-Off and Efficiency**

- There‚Äôs always a **trade-off between memory usage and runtime performance.**  
- **Space efficiency** and **time efficiency** often move in opposite directions.  
- More memory (space) ‚Üí faster algorithms (less recomputation).  
- Less memory ‚Üí slower algorithms (more recomputation).

üí° **Rule of thumb:**  
> The goal is not to minimize one, but to balance both for your use case.


---

# ‚ö°Ô∏è Instant Pattern Recognition
## Common Time Complexities:
| Code Pattern	| Complexity	| 
| --- | --- | 
| `for i:=0; i<n; i++ (single loop)`	| O(n)	| 
| `for i { for j { ... } } (nested)`	| O(n¬≤) | 	
| `for i { for j { for k { ... } } }`	| O(n¬≥) |	
| `Binary search / divide by 2` |	O(log n)    | 	
| `Recursion with 2 branches` |	O(2‚Åø)       | 	


## üö® Pro Tips for Competitions
* Nested loops ‚Üí usually O(n¬≤)
* Single loop ‚Üí usually O(n)
* Using hash map/set ‚Üí usually O(n) time, O(n) space
* No extra storage ‚Üí O(1) space
* Recursion ‚Üí check depth and branches